Введение
========

fdnet (Formal Described Networks ) представляет собой набор утилит и онтологий позволяющих описывать сети в машино-интерпретируемом формате.

Формат представления данных
===========================

Данные представлены в формате Resource Description Framework (RDF) . RDF является одним из инструментов семантического веба для представления связанных сущностей. Сущности представлены в форме \<\<субъект-предикат-объект\>\>.

В текущей версии мы используем нотацию RDF n3, преобразуя ее в формат RDF XML при помощи утилиты *cwm*. Пример:

    @forSome <#unit_id> .
    <#unit_id>                a                      <Unit_Desc> .
    <#unit_id>                <name>                 "Name of entity" .
    <#unit_id>                <feature>              "555-55-45" .
    <#unit_id>                <predicat>             <#another_id> .

В примере объявляется сущность класса \<\<Unit\_Desc\>\> идентифицируема через \#unit\_id. Эта сущность имеет три свойства: поле *name* с значением \<\<Name of entity\>\>, поле *feature* с значением \<\<Name of entity\>\>, и свойство *predicat*, указывающее на другую сущность идентифицируемое через \#another\_id. Каждая строка в описании заканчивается точкой. Класс (тип) сущности определяется через предикат *a*

Важно: Имена и идентификаторы всех сущностей должны быть уникальными в пределах одной сети.

Онтология
=========

В настоящий момент для представления конфигурации сети разработаны несколько классов. Каждый из классов описывает каку-то определенную сущность и ее характеристики. Описание классов производится в формате RDF Schema в формате XML. Данный момент существуют следующие классы:

-   Rack

-   Unit

-   Switch

-   Port

-   Subnet

-   Server

-   Model

-   Program

Rack
----

Сущность *Rack* описывает серверную стойку.

#### name

Имя, название, идентификатор стойки.

#### sn

Серийный номер. Уникальный идентификатор.

#### maxUnits

Максимальное количество юнитов в стойке.

#### hasUnit

Специальный предикат указывающий на сущность Unit, занимающую место в этой стойке.

#### Пример

    @forSome <#rack1> .
    <#rack1>                a <Rack> .
    <#rack1>                <name>                  "rack" .
    <#rack1>                <sn>                    "555-55-45" .
    <#rack1>                <maxUnits>              "25" .
    <#rack1>                <hasUnit>               <#r1_u0> .
    ...
    <#rack1>                <hasUnit>               <#r1_u24> .

В примере объявляется стойка идентифицируемая по \#rack1. Стойка называется \<\<rack\>\>, с серийным номером 555-55-45 и количеством юнитов в 25. Так же эта стойка заполнена сущностями unit идентифицируемые c \#r1\_u0 до \#r1\_u24.

Unit
----

Сущность *Unit* описывает размещение какого-то устройства в стойке.

#### number

Номер этого юнита в стойке.

#### occupiedBy

В логическом Unit располагается одной устройство, и сущность *occupiedBy* указывает на это устройство.

#### Пример

    @forSome <#r1_u11> .
    <#r1_u11>                a                      <Unit> .
    <#r1_u11>                <number>               "11" .
    <#r1_u11>                <occupiedBy>           <#Switch2> .

    @forSome <#r1_u12> .
    <#r1_u12>                a                      <Unit> .
    <#r1_u12>                <number>               "12" .
    <#r1_u12>                <occupiedBy>           <#APMS> .

В данном примере представлены два юнита идентифицируемые через \#r1\_u11 и \#r1\_u12. Эти сущности описывают юниты 11 и 12 соответственно. В первом случае этот юнит занят оборудованием идентифицируемом через \#Switch2, а во втором - \#APMS

Switch
------

Сущность *Switch* описывает сетевой коммутатор.

#### name

Коммутатор обладает свойством имени.

#### sn

Коммутатор обладает уникальным идентификатором.

#### model

Сетевой коммутатор имеет физические характеристики и эти характеристики описаны в моделе.

#### mngPort

В коммутаторе может присутствовать сконфигурированный порт управления.

#### port

В коммутаторе может присутствовать сетевой порт и эта сущность на него ссылается.

#### ip

У коммутатора может быть свой собственный IP адрес.

    @forSome <#Switch2> .
    <#Switch2>              a                      <Switch> .
    <#Switch2>              <name>                 "Switch2" .
    <#Switch2>              <sn>                   "111-456" .
    <#Switch2>              <model>                <#CISCO2950> .
    <#Switch2>              <mngPort>              "0" .
    <#Switch2>              <port>                 <#sw2_p1> .
    <#Switch2>              <port>                 <#sw2_p2> .

В примере объявляется коммутатор идентифицируемый через \#Switch2. У этого устройства есть имя - \<\<Switch2\>\>, серийный номер 111-456, два порта идентифицируемые через \#sw2\_p1 и \#sw2\_2, а так же указан тип модели, идентифицируемые через \#CISCO2950

Port
----

Сущность порт описывает физический порт на коммутаторе.

#### number

У порта есть основное свойство - его номер.

#### type

Тип порта: UTP, оптика.

#### speed

Скорость: 10/100/1000Mbps

#### connectedWith

Какое устройство подсоединено к этому порту.

#### Пример

    @forSome <#sw1_p2> .
    <#sw1_p2>               a                       <Port> .
    <#sw1_p2>               <number>                "2" .
    <#sw1_p2>               <speed>                 "1Gb" .
    <#sw1_p2>               <type>                  "UTP" .
    <#sw1_p2>               <connectedWith>         <#S3> .

В этом примере \#sw1\_p2 является идентификатором порта. \#S3 - идентификатор устройства подключенного к этому порту.

Subnet
------

Подсеть является логической сущностью объединяющая в себе один или несколько логических серверов. В любой цифровой сети должна пресутстовать хотя бы одна логическая подсеть.

#### name

Сущеность *Subnet* обладает свойством имени.

#### hasServer

В подсеть могут входить сервера.

#### Пример


    @forSome <#net1> .
    <#net1>         a               <Subnet> .
    <#net1>         <name>          "NET1" .
    <#net1>         <hasServer>     <#SPS> .
    <#net1>         <hasServer>     <#APMS> .

    @forSome <#net2> .
    <#net2>         a <Subnet> .
    <#net2>         <name>          "NET2" .
    <#net2>         <hasServer>     <#SS> .

В примере объявлены две подсети. Первая идентифицируется при помощи \#net1, вторая - \#net2. Первая подсеть имеет имя \<\<NET1\>\> и в ней присутствуют два сервера идентифицируемые через \#SPS и \#APMS. Вторая подсеть имеет имя \<\<NET2\>\> и в ней присутствует сервер идентифицируемые через \#SS.

Server
------

Сущность *Server* является важной сущностью в цифровой сети. Во-первых, сервер является одновременно физической и логической сущность. Физической, так как сервер размещается в юнитах, которые находся в стойках. Физический сервер описан при помощи модели, содержащей физические характеристики (см. [model]). В тоже время, логический сервер является частью логической подсети, в нем исполняются логические программы, коммуницирующие с другими сетевыми программами. Во вторых, правила сетевой безопасности описываются на основе сетевых адресов привязанных к конкретным серверам. В тоже время, правила контролируют поведение трафика, источником которых являются программы, исполняющиеся внутри логических серверов. В третьих, для уменьшения сложности цифровой сети, сервер может выступать в качестве реплики какого-то другого сервера. В этом случае он полностью повторяет функционал реплецируемого сервера, но не содержит собственного.

#### name

У сервера есть свойство имени. Он дожен быть назван.

#### ip

У сервера есть сетевой адрес.

#### model

Сервер обладает физическими характеристиками, описанными в виде модели.

#### hasProgram

На логическим сервере могут исполняться программы.

#### replica

Сервер может быть репликой какого-то другого сервера.

#### description

Поле с описанием (любыми комментариями) о сервере.

#### Пример


    @forSome <#SS> .
    <#SS>           a               <Server> .
    <#SS>           <name>          "SS" .
    <#SS>           <ip>            "2.1.1.1" .
    <#SS>           <model>         <#simple1U> .
    <#SS>           <hasProgram>    <#ss_sps_1414> .

    @forSome <#S2> .
    <#S2>           a               <Server> .
    <#S2>           <name>          "S2" .
    <#S2>           <ip>            "2.3.1.1" .
    <#S2>           <model>         <#simple1U> .
    <#S2>           <replica>       <#SS> .

В данном примере объявляются два сервера идентифицируемые соответственно через \#SS и \#S2. Первый сервер называется \<\<SS\>\>, имеет сетевой адрес \<\<2.1.1.1\>\>, построен на основе модели идентифицируемой через \#simple1U, а так же внутри сервера исполняется программа идентифицируемая через \#ss\_sps\_1414. Второй сервер называется \<\<S2\>\>, он имеет сетевой адрес \<\<2.3.1.1\>\>, он так же построен на основе модели \#simple1U. В отличие от сервера \#SS, второй сервер является репликой сервера идентифицируемого через \#SS, а значит на нем нет собственных сервисов.

Model
-----

*Model* является логической сущностью описывающей физические характеристики сетевого оборудования.

#### name

Модель устройства, имя.

#### size

Высота устройства в юнитах.

#### power

Потребляемая мощность, в Ваттах.

#### cooling

Требования по охлаждению, BTU/hr (британская термическая единица в час)

#### weight

Масса устройства в килограммах.

#### Пример

    @forSome <#CISCO2950> .
    <#CISCO2950>            a               <Model> .
    <#CISCO2950>            <name>          "Cisco Catalyst 2950-24" .
    <#CISCO2950>            <size>          "1U" .
    <#CISCO2950>            <power>         "30" .
    <#CISCO2950>            <cooling>       "nan" .
    <#CISCO2950>            <weight>        "3" .

В данном примере описано сетевое оборудование Cisco Catalust 2950-24 идентифицируемое через \#CISCO2950. Этот тип оборудования имеет название, оно занимает 1U, требует 30Ват мощности, имеет массу в 3 кг и по нему отсетствует информация о требованиях к охлаждению.

Program
-------

*Program* является ключевой сущностью при описании взаимодействия. Именно программы могут коммуницировать друг с другом.

#### name

У программы есть имя.

#### listenPort

Программа может открывать порт и \<\<слушать\>\> обращения к нему. Программа выступает в роли программы-сервера.

#### communicateWith

Программа может взаимодействовать с другими программами. В этом случае взаимодействие с программой указывается через предикат *communicateWith*

#### Пример


    @forSome <#sps_mysql_3306> .
    <#sps_mysql_3306>       a                       <Program> .
    <#sps_mysql_3306>       <name>                  "mysql" .
    <#sps_mysql_3306>       <listenPort>            "3306" .
    <#sps_mysql_3306>       <communicateWith>       <#sps_mysql_3306> .

    @forSome <#sps_crypto_80> .
    <#sps_crypto_80>        a <Program> .
    <#sps_crypto_80>        <name>          "crypto_server1" .
    <#sps_crypto_80>        <listenPort>    "80" .

    @forSome <#apms_sps_80> .
    <#apms_sps_80>  a                       <Program> .
    <#apms_sps_80>  <name>                  "crypto_client" .
    <#apms_sps_80>  <communicateWith>       <#sps_crypto_80> .

В примере представлены 3 программы. Первая из них идентифицируема через \#sps\_mysql\_3306 называется \<\<mysql\>\>. У этой программы открыт порт 80, при этом она сама может коммуницировать с программой идентифицируемой через \#sps\_mysq\_3306, т.е. с самой собой. Это значит, например, что программа \#sps\_mysql\_3306 может исполняться на нескольких реплицируемых машинах выполняя при этом операции репликации базы данных.

Вторая программа идентифицируется через \#sps\_crypto\_80. Она называется \<\<crypto\_server 1\>\> и выступает в роли программы-сервера открывая порт 80.

Третья программа идентифицируемая через \#apms\_sps\_80 имеет называние \<\<crypto\_client\>\> и выступает в роли программы-клиента коммуницируя с программой идентифицируемой через \#sps\_crypto\_80.

Важно заметить, что все три программы могут исполняться внутри реплицируемых серверов.

fdnet.py
========

Скрипт *fdnet.py* формирует набор SNORT правил на основе формально описанной сети. Необходимым аргументом этого скрипта является путь до описания сети в формате rdf/xml. rdf/xml может быть получен из n3 используя утилиту *cwm*:


    cwm -n3 net.n3 -rdf=b >net.rdf
    python fdnet.py net.rdf

Выходные данные
---------------

Скрипт навыходе скрипт создает несколько файлов:

-   sid-msg.map Набор идентифицаторов и сообщений о вторжении. Каждый номер (sid) используется в описании правила для SNORT/Suricata. Номера уникальны в рамках одной сети.

-   net.dot Исходный файл схемы, на основе которого создается файл .png

-   net.png Наглядное представление структуры сети с точки зрения взаимодействующих компонент (программ), их аффилиация с серверами (и репликами), а так же размещение логических серверов внутри логических сетей.

-   net.rules Файл содержащий правила для SNORT/Suricata

-   net.xlsx Набор таблиц описывающующий физическую конфигурация сети - размещение оборудования, назначение сетевых адресов, характеристики оборудования.

Требования к описанию сети
--------------------------

Минимальными требованиями для создания SNORT правил следующие:

-   Subnet

    -   name

    -   hasServer

-   Server

    -   name

    -   ip

    -   hasProgram

-   Program

    -   name

    -   listenPort

    -   communicateWith

При этом, скрипт корректно отработает, если в цифровой сети будут присутствовать сервера без программ. Скрипт сможет корректно отрабать, если в сети не будет Subnet, если в сети будет находится нискем не взаимодействующая программа, или у сервера не будет указан IP или имя.

Для создания описания физической конфигурации необходимо указать следующий минимальный набор объектов:

-   Rack

    -   hasUnit

    -   name

-   Unit

    -   occupiedBy

    -   number

-   Server

    -   name

    -   connectedWith

    -   ip

    -   model

-   Model

    -   name

    -   power

    -   size

    -   weight

    -   cooling

-   Port

    -   name

    -   number

    -   connectedWith

TODO 
-----

Хотелось бы доработать следующие моменты:

-   добавить набор ключей для раздельной генерации правил, диаграмм и других материалов

-   Нужна валидация цифровой сети по схеме
